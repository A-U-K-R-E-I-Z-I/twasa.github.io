[
{
	"uri": "https://twasa.github.io/post/python-virtualenv/",
	"title": "Python Virtualenv",
	"tags": [],
	"description": "",
	"content": " Virtualenv的好處  可以隔離函數庫需求不同的專案，讓它們不會互相影響。在建立並啟動虛擬環境後，透過 pip 安裝的套件會被放在虛擬環境中，專案就可以擁有一個獨立的環境。 在沒有權限的情況下安裝新套件 不同專案可以使用不同版本的相同套件 套件版本升級時不會影響其他專案  安裝 pip install virtualenv  建立專案資料夾 mkdir myproject cd myproject  初始化 virtualenv 虛擬環境名稱  activate the corresponding environment #linux . 虛擬環境名稱/bin/activate #windows 虛擬環境名稱\\scripts\\activate  這時候再裝要使用的Python Package pip install XXXX  回到實際環境 deactivate  若因為專案資料夾搬移或更名,請重新locate cd /path/to/your_project_new_dir virtualenv --relocatable your_virtualenv_name  "
},
{
	"uri": "https://twasa.github.io/post/python-html-entity/",
	"title": "Python HTML Entity decode and encode",
	"tags": [],
	"description": "",
	"content": "–– coding: utf-8 – #decode import HTMLParser h = HTMLParser.HTMLParser() print h.unescape('\u0026amp;#35377;\u0026amp;#21151;\u0026amp;#33995;') 許功蓋 #encode a = u'許功蓋' a.encode('ascii', 'xmlcharrefreplace') '\u0026amp;#35377;\u0026amp;#21151;\u0026amp;#33995;'  "
},
{
	"uri": "https://twasa.github.io/post/flask-quick-start-guide/",
	"title": "Flask Quick Start Guide",
	"tags": [],
	"description": "",
	"content": " #Flask Quickstart\nRequirements  Python Pip virtualenv Flask : a web development framework Werkzeug：a toolkit for WSGI Jinja2：renders templates  virtualenv：multiple side-by-side installations of Python  安裝：pip install virtualenv 基本使用方式：  ### 先建立專案資料夾 mkdir myproject cd myproject ### 初始化 virtualenv env ### activate the corresponding environment . venv/bin/activate or venv\\scripts\\activate ### 這時候再裝Flask pip install Flask ### 回到實際環境 deactivate ### 若因為目錄搬移或更名 需重新locate cd /path/to/your_project_new_dir virtualenv --relocatable your_virtualenv_name  建立第一個app(記得啟動venv), save it as hello.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!'  執行 # Unix Like: export FLASK_APP=hello.py python -m flask run * Running on http://127.0.0.1:5000/ # Windows: set FLASK_APP=hello.py python -m flask run --host=0.0.0.0 * Running on http://127.0.0.1:5000/ # Debug Mode: # export FLASK_DEBUG=1  Routing  beautiful URLs 程式範例：\n@app.route('/') def index(): return 'Index Page' @app.route('/hello') def hello(): return 'Hello, World'   Variable Rules  add variable parts to a URL ==string== accepts any text without a slash (the default) ==int== accepts integers ==float== like int but for floating point values ==path== like the default but also accepts slashes ==any== matches one of the items provided ==uuid== accepts UUID strings  @app.route('/user/\u0026lt;username\u0026gt;') def show_user_profile(username): # show the user profile for that user return 'User %s' % username @app.route('/post/\u0026lt;int:post_id\u0026gt;') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id  Unique URLs / Redirection Behavior 有斜線跟沒斜線的差異  helps search engines avoid indexing the same page twice 有斜線當網址輸入/projects or /projects/ 都會看的到相同結果(will cause Flask to redirect to the canonical URL with the trailing slash)  @app.route('/projects/') def projects(): return 'The project page' ## 沒斜線當輸入/about看的到結果，輸入/about/ 會顯示Not Found @app.route('/about') def about(): return 'The about page'  URL Building  build a URL to a specific function using url_for() function 好處 Reversing is often more descriptive than hard-coding the URLs. More importantly, it allows you to change URLs in one go, without having to remember to change URLs all over the place. URL building will handle escaping of special characters and Unicode data transparently for you, so you don’t have to deal with them. If your application is placed outside the URL root (say, in /myapplication instead of /), url_for() will handle that properly for you.\n examples:\n  \u0026gt;\u0026gt;\u0026gt; from flask import Flask, url_for \u0026gt;\u0026gt;\u0026gt; app = Flask(__name__) \u0026gt;\u0026gt;\u0026gt; @app.route('/') ... def index(): pass ... \u0026gt;\u0026gt;\u0026gt; @app.route('/login') ... def login(): pass ... \u0026gt;\u0026gt;\u0026gt; @app.route('/user/\u0026lt;username\u0026gt;') ... def profile(username): pass ... \u0026gt;\u0026gt;\u0026gt; with app.test_request_context(): ... print url_for('index') ... print url_for('login') ... print url_for('login', next='/') ... print url_for('profile', username='John Doe') ... / /login /login?next=/ /user/John%20Doe  HTTP Methods  By default, a route only answers to GET requests examples:  from flask import request @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': do_the_login() else: show_the_login_form()   GET: The browser tells the server to just get the information stored on that page and send it. This is probably the most common method. HEAD: The browser tells the server to get the information, but it is only interested in the headers, not the content of the page. An application is supposed to handle that as if a GET request was received but to not deliver the actual content. In Flask you don’t have to deal with that at all, the underlying Werkzeug library handles that for you. POST: The browser tells the server that it wants to post some new information to that URL and that the server must ensure the data is stored and only stored once. This is how HTML forms usually transmit data to the server. PUT: Similar to POST but the server might trigger the store procedure multiple times by overwriting the old values more than once. Now you might be asking why this is useful, but there are some good reasons to do it this way. Consider that the connection is lost during transmission: in this situation a system between the browser and the server might receive the request safely a second time without breaking things. With POST that would not be possible because it must only be triggered once. DELETE: Remove the information at the given location. OPTIONS: Provides a quick way for a client to figure out which methods are supported by this URL. Starting with Flask 0.6, this is implemented for you automatically.  Static Files To generate URLs for static files, use the special \u0026lsquo;static\u0026rsquo; endpoint name: url_for(\u0026lsquo;static\u0026rsquo;, filename=\u0026lsquo;style.css\u0026rsquo;) The file has to be stored on the filesystem as static/style.css.\nRendering Templates  用python產生HTML一點也不有趣而且是個累贅，所以Flask使用Jinja2 template engine來處理HTML 也可避免自己要做HTML escaping來維持App的安全 use the render_template method a simple example of how to render a template:  from flask import render_template @app.route('/hello/') @app.route('/hello/\u0026lt;name\u0026gt;') def hello(name=None): return render_template('hello.html', name=name)   Here is an example template:  \u0026lt;!doctype html\u0026gt; \u0026lt;title\u0026gt;Hello from Flask\u0026lt;/title\u0026gt; {% if name %} \u0026lt;h1\u0026gt;Hello {{ name }}!\u0026lt;/h1\u0026gt; {% else %} \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; {% endif %}  Flask will look for templates in the templates folder. So if your application is a module, this folder is next to that module, if it’s a package it’s actually inside your package: Case 1: a module: /application.py /templates /hello.html Case 2: a package: /application /__init__.py /templates /hello.html  The Request Object  request object most common operations  from flask import request @app.route('/login', methods=['POST', 'GET']) def login(): error = None if request.method == 'POST': if valid_login(request.form['username'], request.form['password']): return log_the_user_in(request.form['username']) else: error = 'Invalid username/password'  # the code below is executed if the request method was GET or the credentials were invalid return render_template('login.html', error=error) #To access parameters submitted in the URL (?key=value) you can use the args attribute: searchword = request.args.get('key', '')  File Uploads  set the enctype=\u0026ldquo;multipart/form-data\u0026rdquo; attribute on your HTML form 上傳的檔案可儲存在memory或filesystem it also has a save() method that allows you to store that file on the filesystem  from flask import request @app.route('/upload', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': f = request.files['the_file'] f.save('/var/www/uploads/uploaded_file.txt')   想取得檔案在client端為上傳之前的檔名可以存取 filename attribute，然而這是有可能被偽造的 如果你想使用client端為上傳之前的檔名，來存放到server上透過Werkzeug 提供的 secure_filename() function  from flask import request from werkzeug.utils import secure_filename @app.route('/upload', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': f = request.files['the_file'] f.save('/var/www/uploads/' + secure_filename(f.filename))  Cookies  Reading cookies:  from flask import request @app.route('/') def index(): username = request.cookies.get('username') # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing.   Storing cookies:  from flask import make_response @app.route('/') def index(): resp = make_response(render_template(...)) resp.set_cookie('username', 'the username') return resp  Redirects and Errors  To redirect a user to another endpoint, use the redirect() function To abort a request early with an error code, use the abort() function  from flask import abort, redirect, url_for @app.route('/') def index(): return redirect(url_for('login')) @app.route('/login') def login(): abort(401) this_is_never_executed()  customize the error page, you can use the errorhandler() decorator from flask import render_template @app.errorhandler(404) def page_not_found(error): return render_template('page_not_found.html'), 404  About Responses  return value from a view function is automatically converted into a response object The logic that Flask applies to converting return values into response objects is as follows If a response object of the correct type is returned it’s directly returned from the view. If it’s a string, a response object is created with that data and the default parameters. If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form (response, status, headers) or (response, headers) where at least one item has to be in the tuple. The status value will override the status code and headers can be a list or dictionary of additional header values. If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object.  ##get hold of the resulting response object inside the view use the make_response() function Imagine you have a view like this:\n@app.errorhandler(404) def not_found(error): return render_template('error.html'), 404  You just need to wrap the return expression with make_response() and get the response object to modify it, then return it:\n@app.errorhandler(404) def not_found(error): resp = make_response(render_template('error.html'), 404) resp.headers['X-Something'] = 'A value' return resp  Sessions  allows you to store information specific to a user from one request to the next implemented on top of cookies for you and signs the cookies cryptographically user could look at the contents of your cookie but not modify it examples:  from flask import Flask, session, redirect, url_for, escape, request app = Flask(__name__) @app.route('/') def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in' @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' \u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=text name=username\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=submit value=Login\u0026gt; \u0026lt;/form\u0026gt; ''' @app.route('/logout') def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index')) # set the secret key. keep this really secret: app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'  How to generate good secret keys in python import os os.urandom(24)  About cookie-base sessions size * A note on cookie-based sessions: Flask will take the values you put into the session object and serialize them into a cookie. If you are finding some values do not persist across requests, cookies are indeed enabled, and you are not getting a clear error message, check the size of the cookie in your page responses compared to the size supported by web browsers. *\nLogging * The attached logger is a standard logging Logger, so head over to the official logging documentation for more information. *\napp.logger.debug('A value for debugging') app.logger.warning('A warning occurred (%d apples)', 42) app.logger.error('An error occurred')  Hooking in WSGI Middlewares  If you want to add a WSGI middleware to your application you can wrap the internal WSGI application. For example if you want to use one of the middlewares from the Werkzeug package to work around bugs in lighttpd, you can do it like this: https://docs.python.org/library/logging.html  from werkzeug.contrib.fixers import LighttpdCGIRootFix app.wsgi_app = LighttpdCGIRootFix(app.wsgi_app)  Using Flask Extensions  Extensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask. http://flask.pocoo.org/docs/0.11/extensions/#extensions  Deploying to a Web Server  http://flask.pocoo.org/docs/0.11/deploying/#deployment  "
},
{
	"uri": "https://twasa.github.io/_header/",
	"title": "_Header",
	"tags": [],
	"description": "",
	"content": " William\u0026rsquo;s Blog "
},
{
	"uri": "https://twasa.github.io/",
	"title": "_Index",
	"tags": [],
	"description": "",
	"content": "我叫william 個人自介如下：\n我本職並非資訊科系，但對程式設計感興趣 之前從事職業是資訊管理人員目前待業中，想轉換跑道成為程式設計人員 目前都是靠自學，基礎程式語言，使用過 Python 語言，基本HTML略懂 也知道如何建立環境運行與撰寫簡單的PHP 基本上只寫過小程式，還請多多指教\n"
},
{
	"uri": "https://twasa.github.io/post/hugo-how-to/",
	"title": "Hugo A Fast and Flexible Website Generator",
	"tags": [],
	"description": "",
	"content": " Quick Start Guide  Hugo download\n https://github.com/gohugoio/hugo/releases  Install Hugo\n https://gohugo.io/getting-started/installing/  Create a blog folder\n  hugo new site blog   go in to the blog folder and modify config.toml for your github url  baseURL = \u0026quot;https://\u0026lt;your-github-account\u0026gt;.github.io/\u0026quot;   create new page  hugo new about.md   create new post  hugo new post/first.md   install a theme  cd themes git clone https://github.com/xxx/xxx.git   localhost server preview  hugo server --buildDrafts --watch   references  https://gohugo.io/overview/introduction/  themes\n https://github.com/spf13/hugoThemes  deploy to github\n Create a blog git repository on GitHub Create a .github.io repository on GitHub In your blog folder, run commands as below   git init git remote add origin git@github.com:\u0026lt;your-github-account\u0026gt;/blog.git git rm -r public git submodule add git@github.com:\u0026lt;your-github-account\u0026gt;/\u0026lt;your-github-account\u0026gt;.github.io.git public git add . git commit -m \u0026quot;Hugo content update\u0026quot; git push -u origin master hugo --buildDrafts cd public git add . git commit -m \u0026quot;Blog update\u0026quot; git push origin master   In your blog folder, create a batch file for one click deploy.  windows : save below content as .cmd   set workdir=%~dp0 set current=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2% cd %workdir% git add -A git commit -m \u0026quot;Hugo content update %current%\u0026quot; git push -u origin master hugo --buildDrafts cd public git add -A git commit -m \u0026quot;Blog update %current%\u0026quot; git push origin master   linux : save below content as .sh  #!/bin/bash workdir=\u0026quot;$( cd \u0026quot;$( dirname \u0026quot;${BASH_SOURCE[0]}\u0026quot; )\u0026quot; \u0026amp;\u0026amp; pwd )\u0026quot; cd $workdir git add -A git commit -m \u0026quot;Hugo content update `date`\u0026quot; hugo --buildDrafts cd public git add -A git commit -m \u0026quot;Blog update `date`\u0026quot; git push origin master  "
},
{
	"uri": "https://twasa.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://twasa.github.io/post/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://twasa.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]